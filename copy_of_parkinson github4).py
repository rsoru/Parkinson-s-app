# -*- coding: utf-8 -*-
"""Copy of parkinson_2 (1).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rebDuwYza1uBRJ1t-p0rc9phsq6RgkZ8

#**Import Libraries**
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import plotly.express as px # high-level API for creating interactive visualizations


from catboost import CatBoostClassifier
from sklearn.svm import LinearSVC, SVC
from lightgbm import LGBMClassifier
from xgboost import XGBClassifier, XGBRFClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.neural_network import MLPClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier, ExtraTreesClassifier
from sklearn.ensemble import GradientBoostingClassifier, HistGradientBoostingClassifier, VotingClassifier

from sklearn.preprocessing import StandardScaler, LabelEncoder
from sklearn.model_selection import train_test_split, GridSearchCV, RandomizedSearchCV, cross_val_score
from scipy.stats import reciprocal, uniform
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report, roc_auc_score, roc_curve, auc, r2_score

import warnings
warnings.filterwarnings("ignore")

from google.colab import files
uploaded = files.upload()

df = pd.read_csv("parkinsons.data.csv")

"""**Features Explanation**

 * name - ASCII subject name and recording number

* MDVP:Fo(Hz) - Average vocal fundamental frequency

* MDVP:Fhi(Hz) - Maximum vocal fundamental frequency

* MDVP:Flo(Hz) - Minimum vocal fundamental frequency

* MDVP:Jitter(%)

* MDVP:Jitter(Abs)

* MDVP:RAP

* MDVP:PPQ

* jitter DDP

* MDVP:Shimmer

* MDVP:Shimmer(dB)

* Shimmer:APQ3

* Shimmer:APQ5

* MDVP:APQ

* Shimmer:DDA - Several measures of variation in amplitude

* NHR

* HNR - Two measures of ratio of noise to tonal components in the voice

* status - Health status of the subject (1) - Parkinson's, (0) - healthy

* RPDE

* D2 - Two nonlinear dynamical complexity measures

* DFA - Signal fractal scaling exponent

* spread1

* spread2

* PPE - Three nonlinear measures of fundamental frequency variation 9

#**Data Visualization**
"""

df.head()

df.info()

"""#**Missing Data Handeling**"""

df.isnull().values.any()

df.duplicated().sum()

df.describe().T

"""📌 Intended Use & Clinical Context

This AI model is developed to support **early detection of Parkinson’s Disease** based on acoustic features from patient voice recordings. It performs **binary classification** (Parkinson’s vs. Healthy) and is intended to assist healthcare professionals in decision-making during initial screenings.

👤 Intended Users
- Neurologists
- General Practitioners (especially in under-resourced settings)
- Speech Therapists
- Clinical Researchers

#########🚀 Deployment Scenario
- As part of a clinical decision support system (CDSS)
- Embedded in telemedicine or mobile screening apps
- Operated in rural clinics via web interface

#**Exploratory Data Analysis**
"""

# Map numeric status to readable labels
label_map = {0: 'Healthy', 1: "Parkinson's"}
status_counts = df['status'].map(label_map).value_counts()

# Define custom pastel colors
colors = ['#E57373','#6BA292']

# Plot pie chart
status_counts.plot(
    kind='pie',
    labels=status_counts.index,
    autopct='%1.1f%%',
    colors=colors,
    figsize=(6, 6),
    startangle=90,
    explode=[0.02, 0.02],
    shadow=True
)

plt.title('Distribution of Status')
plt.ylabel('')
plt.tight_layout()
plt.show()
print("Percentage of patients diagnosed as healthy = {0:.2f}%".format((df[df.status == 0].shape[0]/df.shape[0])*100))
print("Percentage of patients diagnosed with Parkinson's disease = {0:.2f} %".format((df[df.status == 1].shape[0]/df.shape[0])*100))

# Models like lgbm do not like json type names

df.rename(columns={'MDVP:Fo(Hz)': 'MDVP_Fo(Hz)', 'MDVP:Fhi(Hz)': 'MDVP_Fhi(Hz)',
        'MDVP:Flo(Hz)': 'MDVP_Flo(Hz)', 'MDVP:Jitter(%)': 'MDVP_Jitter(%)',
        'MDVP:Jitter(Abs)': 'MDVP_Jitter(Abs)', 'MDVP:RAP': 'MDVP_RAP',
        'MDVP:PPQ': 'MDVP_PPQ', 'Jitter:DDP': 'Jitter_DDP', 'MDVP:Shimmer': 'MDVP_Shimmer',
        'MDVP:Shimmer(dB)':'MDVP_Shimmer(dB)', 'Shimmer:APQ3': 'Shimmer_APQ3',
        'Shimmer:APQ5': 'Shimmer_APQ5', 'MDVP:APQ': 'MDVP_APQ', 'Shimmer:DDA': 'Shimmer_DDA'}, inplace=True)

"""Changes of features according to status"""

num_cols = list(df.select_dtypes(include="float64").columns)

"""# Correlation Between Variables

The Relationship Between Variables of Parkinson's Status
"""

parkinson_corr = df.drop("name", axis=1).corr()["status"]
parkinson_corr = parkinson_corr.drop("status", axis=0)
parkinson_corr = parkinson_corr.sort_values(ascending=False)

plt.figure(figsize=(11,4))
plt.bar(x=parkinson_corr.index, height=parkinson_corr, color="#a0522d")
plt.xticks(rotation=90)
plt.axhline(0, color="k", lw=0.6)
plt.grid(True, axis="x", lw=0.3, color="#a0522d")
plt.title("Relationship Between Stages of Liver Cirrhosis and Other Variables", fontsize=12)
plt.show()

plt.figure(figsize=(12,8))
sns.set(font_scale=0.8)
sns.heatmap(df.drop("name", axis=1).corr(), annot=True, linewidths=0.4, fmt='.3f',
            cmap="Blues", annot_kws={'size': 7, 'rotation': 45})
plt.title("Correlation Between Features", fontsize=16)
plt.show()

"""#**Building and Analysis of Machine learning models**

Train-Test split
"""

y = df["status"]
X = df.drop(["name", "status"], axis=1)
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.20, stratify=y, random_state=42)

"""Standardization"""

scaler = StandardScaler()
X_train_scaled = scaler.fit_transform(X_train)
X_test_scaled = scaler.transform(X_test)

"""Accuracy scores of models with cross-validation"""

from sklearn.pipeline import Pipeline
from imblearn.pipeline import Pipeline as ImbPipeline
from imblearn.over_sampling import SMOTE
from sklearn.model_selection import cross_val_score

models = [RandomForestClassifier(), HistGradientBoostingClassifier(),
              CatBoostClassifier(verbose=False), XGBClassifier(),
               GradientBoostingClassifier(), LogisticRegression(max_iter=1000, class_weight='balanced'),  KNeighborsClassifier()]

model_name_list = []
accuracy_list = []

for model in models:
    pipeline = ImbPipeline([
        ('smote', SMOTE(random_state=42)),
        ('scaler', StandardScaler()),
        ('clf', model)
    ])

    scores = cross_val_score(pipeline, X, y, cv=15, scoring="accuracy", n_jobs=-1)

    model_name_list.append(model.__class__.__name__)
    accuracy_list.append(scores.mean())

    print(f"{model.__class__.__name__} cross validation score: {scores.mean():.4f}")
    print("-" * 50)

plt.figure(figsize=(8,5))
sns.barplot(x=accuracy_list, y=model_name_list, palette="flare")
plt.title("Accuracy scores of models with cross-validation", fontsize=15)
plt.axvline(0.9, ls="--", lw=0.6, color="b")
plt.text(0.90, 6, s="0.9", fontsize=13, color="r")
plt.show()

"""# Hyperparameter Optimization

XGBClassifier Hyperparameter Optimization
"""

study_xgb = optuna.create_study(direction="maximize")

def objective(trial):
    params_xgb = {
        'n_estimators': trial.suggest_int("n_estimators", 100, 1000),
        'max_depth': trial.suggest_int("max_depth", 3, 10),
        'learning_rate': trial.suggest_float("learning_rate", 0.01, 0.3, log=True),
        'gamma': trial.suggest_float("gamma", 0, 0.5),
        'min_child_weight': trial.suggest_int("min_child_weight", 1, 10),
        'colsample_bytree': trial.suggest_float("colsample_bytree", 0.6, 1.0),
        'colsample_bylevel': trial.suggest_float("colsample_bylevel", 0.6, 1.0),
        'reg_alpha': trial.suggest_float("reg_alpha", 0, 10),
        'reg_lambda': trial.suggest_float("reg_lambda", 0, 10),
        'random_state': 42,
        'n_jobs': -1
    }

    model = XGBClassifier(**params_xgb)

    # Use cross-validation on the training set only
    scores = cross_val_score(model, X_train, y_train, cv=5, scoring="accuracy", n_jobs=-1)
    return scores.mean()  # Return mean CV accuracy

study_xgb.optimize(objective, n_trials=50, n_jobs=-1)

print("Best trial:")
print(f"Accuracy: {study_xgb.best_trial.value:.4f}")
print(f"Params: {study_xgb.best_trial.params}")#new

"""GradientBoostingClassifier Hyperparameter Optimization"""

study_grad = optuna.create_study(direction="maximize")

def objective(trial):
    params_grad = {
        'loss': trial.suggest_categorical('loss',['log_loss', 'exponential']),
        'n_estimators': trial.suggest_int("n_estimators", 50, 800),
        'learning_rate': trial.suggest_float("learning_rate", 0.1, 0.3),
        'max_depth': trial.suggest_int("max_depth", 2, 16),
        'min_samples_split': trial.suggest_int("min_samples_split", 2, 20),
        'subsample': trial.suggest_float("subsample", 0.4, 0.99),
        'min_samples_leaf': trial.suggest_int('min_samples_leaf', 1, 20),
        'random_state': 42}

    grad = GradientBoostingClassifier(**params_grad)
    grad.fit(X_train_scaled, y_train)
    y_pred = grad.predict(X_test_scaled)
    acc = accuracy_score(y_test, y_pred)
    return acc

study_grad.optimize(objective, n_trials=50, n_jobs=-1)
print("Best trial:")
print(" Value: {}".format(study_grad.best_trial.value))
print(" Params: {}".format(study_grad.best_trial.params))

"""CatBoostClassifier Hyperparameter Optimization"""

study_catb = optuna.create_study(direction="maximize")

def objective(trial):
    params_catb = {
        'learning_rate': trial.suggest_float("learning_rate", 0.2, 0.3),
        #'max_depth': trial.suggest_int("max_depth", 2, 16),
        'max_depth': 5,
        #'n_estimators': trial.suggest_int("n_estimators", 500, 2000),
        'n_estimators': 1939,
        'l2_leaf_reg': trial.suggest_float("l2_leaf_reg", 0, 0.1),
        #'border_count': trial.suggest_int("border_count", 5, 255),
        'border_count': 20,
        'leaf_estimation_iterations': trial.suggest_int("leaf_estimation_iterations", 20, 100),
        'random_strength': trial.suggest_float("random_strength", 0, 0.1),
        #'bagging_temperature': trial.suggest_int("bagging_temperature", 2, 20),
        'bagging_temperature': 19,'colsample_bylevel': trial.suggest_float("colsample_bylevel", 0.2, 0.4),
        'random_state': 42,
        'verbose': False}

    model_catb = CatBoostClassifier(**params_catb)

    model_catb.fit(X_train_scaled, y_train)
    y_pred = model_catb.predict(X_test_scaled)
    acc = accuracy_score(y_test, y_pred)
    return acc

study_catb.optimize(objective, n_trials=50, n_jobs=-1)
print("Best trial:")
print(" Value: {}".format(study_catb.best_trial.value))
print(" Params: {}".format(study_catb.best_trial.params))

"""Final models after optimization"""

xgb_1 = XGBClassifier(**study_xgb.best_trial.params, random_state=42).fit(X_train_scaled, y_train)

grad_2 = GradientBoostingClassifier(**study_grad.best_trial.params, random_state=42).fit(X_train_scaled, y_train)

catb_3 = CatBoostClassifier(**study_catb.best_trial.params, n_estimators=1939, max_depth=5,
                border_count=20, verbose=False, bagging_temperature=19, random_state=42).fit(X_train_scaled, y_train)

accuracy_list = []
model_name_list = []

for clf in (xgb_1, grad_2, catb_3):
    y_pred = clf.predict(X_test_scaled)

    acc = accuracy_score(y_test, y_pred)
    model_name = clf.__class__.__name__
    accuracy_list.append(acc)
    model_name_list.append(model_name)
    print(f"{clf.__class__.__name__} :  {accuracy_score(y_test, y_pred)}")

plt.figure(figsize=(8,3.5))
sns.barplot(x=accuracy_list, y=model_name_list, palette="flare")
plt.title("Accuracy scores after optimization", fontsize=15)
plt.axvline(0.978, ls="--", lw=0.7, color="b")
plt.text(0.92, 3, s="0.978", fontsize=15, color="r")
plt.show()

"""# Classification Reports"""

for i in (xgb_1, grad_2, catb_3):
    y_pred = i.predict(X_test_scaled)
    clas_report = classification_report(y_test, y_pred)
    print(f"\n----------------- {i.__class__.__name__} ---------------\n")
    print(clas_report)

"""*   Precision: Measures how many predicted positive cases were actually positive.

*   Recall: Measures how many actual positive cases were correctly identified.

* F1-score: Balances precision and recall—higher values indicate a strong classifier.

* Accuracy: Shows overall correctness of predictions.

Confusion Matrices
"""

plt.figure(figsize=(11, 3.5))
j = 0
for i in (xgb_1, grad_2, catb_3):
    y_pred = i.predict(X_test_scaled)
    cm = confusion_matrix(y_test, y_pred)

    plt.subplot(1,3, j+1)
    sns.heatmap(cm, annot=True, fmt="g", cmap="mako", linewidths=0.5)
    plt.title(f"{i.__class__.__name__}", fontsize=13)
    j += 1
plt.tight_layout()
plt.show()

"""
# ROC Curve
"""

plt.figure(figsize=(12,5))
j = 1
for i in (xgb_1, grad_2, catb_3):
    y_prob = i.predict_proba(X_test_scaled)[:, 1]
    fpr, tpr, thresholds = roc_curve(y_test, y_prob)
    roc_auc = auc(fpr, tpr)


    plt.subplot(1,3, j)
    plt.plot(fpr, tpr, color="blue", label= f"AUC: {roc_auc:.3f}")
    plt.plot([0, 1], [0, 1], color="r", linestyle="--", linewidth=1.4)
    plt.legend(fontsize=14)
    plt.xlabel("False positive rate (fpr)")
    plt.ylabel("True positive rate (tpr)")
    plt.suptitle("ROC Curve")
    j += 1
plt.tight_layout()
plt.show()

#best_model = catb_3  # or xgb_1, or grad_2

"""# **Explainable AI**"""

import shap
import matplotlib.pyplot as plt
import pandas as pd

shap.initjs()

# Set your trained model
best_model = catb_3  # replace with xgb_1 or grad_2 as needed

# Feature names (fallback to columns if not provided)
feature_names = X_test.columns.tolist()

# Initialize SHAP Tree Explainer
explainer = shap.TreeExplainer(best_model)

# Compute SHAP values
shap_values = explainer.shap_values(X_test)

# 📊 1. Global feature importance (bar plot)
plt.figure()
shap.summary_plot(shap_values, X_test, feature_names=feature_names, plot_type="bar")
plt.show()

# 📈 2. Local explanation for a specific patient (force plot)
patient_idx = 0
shap.initjs() # Initialize Javascript for SHAP plots

force_plot = shap.force_plot(
    explainer.expected_value,
    shap_values[patient_idx],
    X_test.iloc[patient_idx],
    feature_names=feature_names
)

# 🔬 3. Dependence plot for a specific feature
plt.figure()
shap.dependence_plot("MDVP_Fo(Hz)", shap_values, X_test, feature_names=feature_names)
plt.show()

# 🔁 4. Interaction plot for two features
plt.figure()
shap.dependence_plot(
    "MDVP_Fo(Hz)",
    shap_values,
    X_test,
    interaction_index="MDVP_Jitter(%)",
    feature_names=feature_names
)
plt.show()

# Step 1: Prepare X_test as DataFrame
X_test_df = pd.DataFrame(X_test, columns=df.drop('status', axis=1).columns)

# Step 2: Use TreeExplainer (recommended for CatBoost)
explainer = shap.TreeExplainer(catb_3)
shap_values_array = explainer.shap_values(X_test_df)  # NumPy array

# Step 3: Convert to SHAP Explanation object
explanation = shap.Explanation(
    values=shap_values_array,
    base_values=explainer.expected_value,
    data=X_test_df.values,
    feature_names=X_test_df.columns.tolist()
)

# ✅ Step 4: Visualize full dataset force plot (training predictions)
shap.initjs()
shap.plots.force(explanation[:100])  # Limit to 100 for performance

#optional xAI
import shap
import pandas as pd
import matplotlib.pyplot as plt

# Assumes model = catb_3, and X_test is a NumPy array
# Step 1: Convert X_test to DataFrame with feature names
X_test_df = pd.DataFrame(X_test, columns=df.drop('status', axis=1).columns)

# Step 2: SHAP TreeExplainer (preferred for CatBoost)
explainer = shap.TreeExplainer(catb_3)

# Step 3: Get SHAP values
shap_values = explainer.shap_values(X_test_df)

# Step 4: Summary plot (beeswarm)
shap.summary_plot(shap_values, X_test_df)

# Step 5: Bar plot
shap.summary_plot(shap_values, X_test_df, plot_type='bar')

# Step 6: Force plot (local explanation for one sample)
sample_idx = 0
shap.initjs()
shap.force_plot(explainer.expected_value, shap_values[sample_idx], X_test_df.iloc[sample_idx])

"""Feature Importance"""

# Built-in feature importance
importances = best_model.feature_importances_

# Sort and visualize
sorted_idx = importances.argsort()[::-1]
plt.barh(range(X_train.shape[1]), importances[sorted_idx], align='center')
plt.yticks(range(X_train.shape[1]), [feature_names[i] for i in sorted_idx])
plt.xlabel("Feature Importance")
plt.title("Parkinson's Voice Analysis - Global Feature Importance")

"""**Clinical Interpretation of Voice Features**

For Parkinson's voice analysis, focus on explaining these clinically meaningful features:

Feature  	Clinical Meaning	Typical Parkinson's Pattern

Jitter	Voice pitch variability	Increased (≥1.04%)
Shimmer	Voice amplitude variability	Increased (≥3.81%)
HNR	Harmonic-to-noise ratio	Decreased (≤20 dB)
PPE	Pitch period entropy	Increased (≥0.5)
VUV	Voiced/unvoiced segments	More irregular transitions![clinical intepretations of voice anallysis of  parkinson patients.png](data:image/png;base64,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pkr4flwk4jjGqBuxvkP2fnuvNe4TpbzsolqexQ11dkKWZvnknkC5h41i4/tD9qdWQSa/BCNOWtGggeEET5kJPLEkcpKsn8gX96dsimPk2f8QjWeM+1I3RT1YihsEN54IorQd9iKstm7O6UGy44LpRrpHW5oTkYKTDuhB0MyfdyfylLB3ZmPzWI2JcuNncxsTiiZLGI47JBzX4DjK1QLSvlnsGZQQd+KOvEi7f+8JHsycP39STK5aQnamd0/M6eg71WPwRMH/VAIzJ/JW1acALYxpnhgQT/yyFn6cA8LO6ROFTclF7z3v8ZOvyRVkqyG59+7xUSft5eF/gk7YcYxTN+J8h+fpU42yVMtqcqaV/csvITvjz+0ef03+zLXvOOQBb8A6OI6yWn4nV5CtXsBY47uiyB73QO928IdgAi9NedVN5hUvb/BrIqecA/Ez5GGpIV4Gxl8ry58Ed9edwcpUFRdG1WUlpW6HtR1xesbpwfWher1eV98kIiIiQq2CzOQ8xnzB/AOmVkFGdmyoQTYRdmbPNBEREXXF4DiyaQel88Ge5geFPSt+vImBNIVhME1EREShzFwZWai55A8Gu5hC3koHfvGSyItpHkRERERECbFnmoiIiIgoIQbTREREREQJMZgmIiIiIkqIwTQRERERUUIMpomIiIiIEmIwTURERESUEINpIiIiIqKEGEwTERERESXEYJqIiIiIKCEG00RERERECTGYJiIiIiJKiME0EREREVFCDKaJiIiIiBJiME1ERERElBCDaSIiIiKihBhMExERERElxGCaiIiIiCihD9Xr9br65kZ477331LeIiIiIaIfYvXu3+taOtGnB9AcffKC+RUREREQ7xEMPPaS+tSNtWjBNRERERLTdMWeaiIiIiCghBtNERERERAkxmCYiIiIiSojBNBERERFRQgymiYiIiIgSYjBNRERERJQQg2kiIiIiooQYTBMRERERJcRgmoiIiIgoIQbTREREREQJMZgmIiIiIkqIwTQRERERUUIMpomIiIiIEmIwTURERESUEINpIiIiIqKEGEwTERERESXEYJqIiIiIKCEG00RERERECTGYJiIiIiJKiME0EREREVFCDKbpAWajmEohVbTVDxJxZjNIpYroztp6rFZBJpVCZtZRP+mQOKbdXy8RtYd1kWijbG4wbReRSqWCr5MV+Ku/g8pJzXKpFAJxUNg62ag8OMLKQKBc6YiyxrKy/TizmZjnmLYzcdOaQaWmfkIdke1m4JraLrX9jVMn1b8J/K0bA2yTzgp64GxuMC2lC1VUq+6rjCxKyOgqzVAW5cZyVVQLaVh5feDjX6d4lScMdTHawVqXKxO5ahXVnOn5qxpWlj3/3akGx1HeYXWiVgu2A0QUh41i3oIxVYavOWyXXUQqv4TsjNLuxgmokUZBuWZXXxuHaKEMjL9WRnbIQr7jaJ+o+7ZEMO1nYPy1AtKwUNIEyT5mDuUpA870XDDwJvJpo1wRET1AnNkSrKEsLvhurm0UdZ1aodyA/ALGB933DIyfz8JYLmEuYkXO8pL6loaB8ak0YJU4KkFbzhYMpgFgEHuHAGfBbnk3awwNA7CwGFFRiQS1XPlzCsXwcR4WAGc6I4ca1YuJzLP2vIIjI2paUrwhabvoDmvG/Xt1W4LLNdYpc6RT7jCu/H+wk0f97qhh2tbfH6313zePibKsd5vkvuQtAMsl/35GHYPml/j3V/0cyvFSl/cuHDVUHvUZdSRWOfFRy57aDhRhe5bx13H1b4Pl1i0vuvV7ie+K2t5gfdSXnxjbFMrG3LQDY9SUvcAuEyNpC/lUzHkl9iIsGBgbVUa7Bk2MDQFWq4v00F40YvAw5glkhxyUZlusi2iDbdFgWnrCUCp3GAN74y1IFFqujIkyqtUC0gCMqbIcasyhMeppF5FK5bHU+KyKarWAMd9allA6mcHKlGeYc8hBaVINysPM41zqHHC+OdRZSDsoTSoXx1oFGWVbylNAaVJ3sZ3HuckVZOVyocO4tQoyqQxKTxRapMc0v99Ke5adGcP8pLgZaand7U8tYsRzzNPLnqFjmbJSSPtTwfz7qT8GdjGlDEtHp48tTWeQWhzx7HMWhpVvBhvmCNLQBw72ogUMZXEi7PhTh1qUE1fselzCXlkuGulQscqtg8r5eYwpZcqZzvjKtl1MITM97EltKCP7RPNzESAr9VFXNjuti2FBMAAzJ4+jlQ+9IXCJ3uVhGIGI2IDxBIC7TsiNTTspWgbMUSNyXUSbYWsG0zUb88uAMRiolQH2ohVSgYkUbZSroGZOoT/P2MS47/8OMOrNO5RDk3FHT5YdDBfKnmFSwMzJgPy8ZzLO+RKcdMG3LcbEBWR1PUDLDoYLnpsCLbnOoSzKvii0mR7TzFUMWXZwHOVCuvn/UJ1uv4kTUwawPA87bu9bYB0iqMpbQFo53s30sXOB3j0HY/p9tvIyUDIxIqLpwIjGogVN7x91TeAc68pJO/XYm64g3otXbkV+r79MnVCWkeVh6oRnew2M59wcYcAu5mGpdczMoZD2jq51WhdlEDw0BjO0WZRzS2aygByxC97wyoA4Tu9yGM+oUlTgbgwNt1f3iTbAFgymbRQnRePgz98KcmYz8mIYDBSsvH9orL1hL9p54pcrrYjeGz/NMsZeGACWlvUXB780RtTC7PbGLK+ghuZNQTqwoFwuEMjp1qlw1znVvJg3yQDR7Q2KWlb2zEbqwvaL9C4HK3EOKaBdR1RPsTE6BkOzfm0wLPfZPb/mRBaGevMUu/xQcsFzHCgnsc+DZpm2y62X2jurppypwm++zJF0M5jstC66QXDIaJ2PHAFye8eDKXDhBgc97ZeG6AEP9uRr00uMvdq6SbSZtkQw7Q985RBaYxavh3rnKofIdMPWwad5KD0FtOPFLlcxxB8B0SwzaGBYeStUZM/OEpwaAGcFTmD/3DqhucJErlNyVuBEpEv5LoYtlm2pG9svb1BiC6zDgXM3POXHPWfqDdDwkHZpAIBTk6GCJkfUXrSAdJZtUC8FznGwnHRUj9stt0redN6XcyFHrNxrmpqKUnOwBO/cDc/Lu6JO62KbRFqUJZ+8EezECtN2r7WZQ7UQMtmwnfaUaINsiWBaDXxDH9elPhqvjcpMD57Y5Squdi4GPeG9wBv+PN9tVy+2+/YHNdOH1J5K0csY7NGkTdFRPY5TbuVkwEl/3nQg68LMoVqtojxlNIJqNbVBbcOar43tHLKL7g2B+/i6YB0dHOywfVXJHuj5Bc2NCtEWsyWCaaKtrtUwZdeEfIevZ6cXw5wt1hn7+2WPWqSov98w6rC7Qu6H2hOt9lQD+mVFmohM9bAXYWlSEGjjdVSPY5ZbZ7YEC2kUYga8YuKzCLYbefohIyMBUdsUpy62ECeIdoXnMotRIF3KShxqHezGfhF1G4NpIo3GkL3kBke9f0a1bqKi6NlspCS4aQTT6mO0OhC5TiV/U17oAxMFATgL85q/V0R+V4faCJRE7qn++bdiP4IBsC7HVSyrDLV7Uj1EisdIaBBCG6ejehyz3OpTGmQdjmCOpNHM7xbzFFr+hkKnddG9wdDeVNpYjBFEN5gjSOt6kms25pc1OegtaOtVQ9j7RJuDwTSRjzLZzjU4jgtTRuDxVqhVUExyYY5g5b2TZR1UTuZFT1djcoAn31KZoOPMKtsXW/PHFfzrlN/vm7hpIiefYOEblraLyCwgRu9TL7bfDUZkXnkc8skI/uMt92Pa0U5sDmyzXNb/QxVo7uPdEkqWgexEYE20GTqqx/HKrej99t6kuXXYy0ZRyZNWJ8S6E1nzaj61XfTUu07rYlSPsolcnCC6QTw9xf8UHDnx2ztfQD5vvbm9wWMRXq9kkB359BGijbdjg2ndJJHAJA8iDTMnn0+bSvlmrBsTZc9MdvmaLAHqMGQnhrIoz4xhftL9jgxKyKKsXtTMXPMZx54ynlkY0z6dIpbBcZQ9z5RtfP8TheDETTlByDdBanovyq9l400O6sX2mzn5TG6xrjhBuZlrPie4sR3yudNhE5sL8Gxz3kK6EJKPb44gvezwwr/FdFSPY5RbY6Isb9KadWhlSpMzrUyoz9/NouytZ259VJZL5YGst7x1XBdDepTVHyfSvNQ6ZkyUlfokJ37rKpNXYB9FHQzWKwf2gu4HZog214fq9XpdfZOINp5d1FxQaWuoVZCZLGG4oA+y9WwUZTARDAqItg5nNoPMwtjWb3vsogy04+WjE22UHdszTUS0mdyJaL5eRKItyJjIIr1cwrmWqS6byUFl2tKmfhBtNgbTRETdVqvg3LSj/MId0VZlIid/4VBN3dgaHFROipS3RD+6RdRjDKaJiLrF/aGOyRLA9A7aTuQvHMZPY9pIBsZfqwbnbhBtEcyZJiIiIiJKiD3TREREREQJMZgmIiIiIkqIwTQRERERUUIMpomIiIiIEmIwTURERESUEINpIiIiIqKEGEwTERERESXEYJqIiIiIKCEG00RERERECTGYJiIiIiJKiME0EREREVFCDKaJiIiIiBJiME1ERERElBCDaSIiIiKihBhMExERERElxGCaiIiIiCghBtNERERERAl9qF6v19U3N8J7772nvkVEREREO8Tu3bvVt3akTQumP/jgA/UtIiIiItohHnroIfWtHWnTgmkiIiIiou2OOdNERERERAkxmCYiIiIiSojBNBERERFRQgymiYiIiIgSYjBNRERERJQQg2kiIiIiooQYTBMRERERJcRgmoiIiIgoIQbTREREREQJMZgmIiIiIkqIwTQRERERUUIMpomIiIiIEmIwTURERESUEINpIiIiIqKEGEwTERERESXEYJqIiIiIKCEG00RERERECTGYJiIiIiJKiME0EREREVFCDKaJYrFRTKWQKtrqB71lF5FKZVCpqR9sX85sZhP2yUHl5CacPyKdWgWZVAqZWUf9ZPuQ+8Aq1V6bZhdTSKWK4GHbWTYtmBYFqkXhUxocu5hC6mQFoc2Pt3LLf7e6eLJg7yxJytV217JeELXLLm7ZdlEELnHLvLwJbtUm0BYmboS3XXu9hesQdd+mBdPmSBqAg/mF8AriLMzDgYGxUUP9qLVBE2NDAKzFiMJsY9ECkB6BqX5E21LvypWJXLWKam6rlRRRho1RE+3szWYyJsqoVssYH1Q/oa3CWV5S39p6lkuYC2/cAQDObAmW+uZWMDiOcrWK8sR2qbWbqYaVZfW9rUXXpoXVITNXRbWaY8yxw2xaMA3zBLJDgLNgh/QuOLAXHCCdTXjRNTA+lQZgYTGswbUXYcFAdoLFesfoebnaWkSwkEaWF2V6oBgwhgBrOqp32sbctANjiHWDiHpr84JpGDBHDWB5HrZu+M2eQ2kZSI90EOiaI0gDsLTRtIPKtAUMjcHcAUEVuRKUKzclyPMKDimK4eLg+55h58ZLHdpzh5rdV8iQs130r6flMLa4MTCmTshejvC84GBOn2d/lO/17mNUGpQuvUQsH3Us3G0Jvh88TsHjHTjWmn1tHAfPctrFwgTKQ/B8Jd+O4DlqHg9l/91llO1Rj4mg+y5licb3qMt6z4UsF9MOAAt5zXcG9r1lOe2NsdF0eD333mhODasfSepx0O9Lo5x7zoP32AaOh3rgdTT5xqHf41m2Ub9826nWm2B5FYtp2hd1ToZmuwR5rDTHxy/GMW25P03i2OZhAXCm3eMsy2vketrbDvUcBvc/uIx3ff42LboO6dpN+YF//brt6OI2U5fVN5MzV58cHa1Pzqyon9RvXBytj45erN9Q35uaqweXluT6Lnr+SLeeej36u2mbizi3anlYmZmsjyplxv37Ud+bN+oXA+tcqc9NBcvXysxc8/+abdF9Z9R7o6OT9Tmn+X7DjYvKZ3J7fNstP5mZVJaV+zM16V/+xsX6qHd75f+Dq1SPh/i/Wj/F8fZvv9gWpU6q3yverM95/q+eO/13RrwXOKcamv1dmbno2/5ub0fzPHvW6R6Pixfrk5r3/bsh1xt1Hj1lYHJKU2YCZVhzjrT7vlKfuxjRJvdAsyyHl3dvXQiW/bA6rj8W4roz6T8P3s9algWNsGuV7nvcNmRqMtimdbt90WyXII+Nd780y67MqNuoKZtR+6OltjVSxHo62Q7dsQqeZ3+519UX3Xv1xnlu3U7q6nA3t5m6axN7ppt5zcEh+e7lMosc2mCqR7K8WdoW4parWgXnph0YU2X4UqEHx1EupAErr73bdzmz51BaTqOg5L8ZE+PNnuLzJTjpgi830pi4gOyQZ8QkZDuMiTIK6eb/Vfai1XG6irM8jIL3S9U0mZDRHdHr16w/djEPC2kUXhv35W6buTKyQw5K56N6RGwU8xaMqbKSQ2pi3P2/XUTeMpCd8R5rE7mCv3dSvx0mcjPZWDnl9qIFDGVxwncecs1j3MPtSBc86zRzKKQBx7Iw7HtfnB/v+bCLeVhDWZR951H+faAOOMDoBU+ZiZEO1yDz8xsjIRB/n/Of840jR6GsUrAn1p5DaTkshU/WS/WYwcD4awWkYSGvVvxlx38eEL8stEX3PZKDMVzw1Y/eti9JGBPBOnxiytDOXQruTzK69XSyHcZEVmnzelzu7SLyFpAuKPNIzBzKUwac6XOB8r3p20wBmxtMuw252vB0M5dZc/HBDsubJVW8ciVuqELyjWUQubQcFgK6ZSjihq9mY15NKQE8QYBo2KO2Q9wMatQqKFm6dbcpsP0GjCcALK9AHDoT4n7UexFS64+u4Xa5aTfu+jTkeYm6sRVBriYlyxxBujHhNGI73AnJLQwORqQI9XQ7DOxVdn9w0ACQhv8Uy/Nz15FBcvgEVHNEUwd0x9nYCyOyrLsGsVd7k7p5RBChTjiWKXxh7btbL6d0gYUs743j61LPQ9yy0K7g97gC57iX7UsXGUPDAJbgKHUqsD8JxV1P/O0Q5bxZBnpb7nU38C5jdAwGHKwoX7zZ20xBmxxMNxue0qynpyWskUpE03sR2gjRjhGjXNVqDjC0F/piJhujWkhUJcuQMaj/awCAswIHgJVXcvca+XRC9HboOQvzcEIa4Hbotl8EcU3mRBaGt+dSrT81B0sAhkMmeoVdxFz2ogVgGEZwUyQHzl3x9AY1t93NpwRab0ccbnBWmkxpck/b2472RO1/BPldzXxSzyuve46F5nsGDYRlFfu5N6ly/7dE/qXocXSm55o3e5G90m69DN68uMQNlXLzF6ifMctCuwLf0xQo1+20LxtKyVfWlkPN/iQUvp6k2yFvWD3/7125l+XoCUN/QyDrpnqju7nbTDqbH0yrPV+yxy145xXSyAUEG0n37s7tKbBnS3AiegBoJ4hfrjoRbNRUBrIzVVSrupd+OLc1+ZSCLu9LKNmb6o7uuD1dXa0/EUFEQ7qgOYbi1b1HjMlHIM5kYbhBtXohirkdrctG96QLwW0Rry4/gtDMif2cMhoXav2EyI0jboAslNwJXl3tjGkhZlnonZjtS5z61QXuc/7nR8vN7eh2LkkMXd+OLVjuW9qO27yNbYFg2p/XHDUk1ZK8Uw/w5dBGDMHSjtKqXEXfnIlnm+p6boHwHgMfY692iE4VtR3aZ5Xai9GPwwsMUXfKO2ysSW9pcSzEPmh6RKWo/RfU1IYQkdvR5rNq5XOAqwXRu3Nu1tmc7Wgl8rt6RzxXtyrysjU5nRtL3Dg7CzYcN/1Jm8IhtaiX8UaKYpaFXmqxH66o+qVtX5KWJ/fYFzbqRiJED7ej++W+RTnqymhbt7eZdLZEMN3Ma64EL9Qeooe52QOhCu+R8OTQzrbOz6QdokW5iixPLfN45QXcO7yscnt0I5+F66ZB6CaAycBVeU/kg+rqiJrv3NTpUK97rBZnbcwHhtCjjoUm+FZEngdJ5P+2+pGOiDxBezHZ0LvMnXfTfTZtO0JFHftOhafmuNwfSWoV0PWaOZGFsVzCufMx0p8i62V4DroqXlnoocj9aGqrfZE3Z8H0thg3gSHpMyKNq3PBbQrR4+1AW+U+Zh0KKUfdHAWMv82UxNYIpj15zYFnAHsNjuPClAFnOhN4yoJdTImZ1edDeiTcHFo+W/oB0qJchZWnWgWZvAVjyvvUgyAzJ2f+K2kAdtF93qgnb00psM6s5zvlkxesvD9H1y5mMK+W5hb5oG5+szcwdWYzCEkXjE9euJcW5uFo6k/4sciIJ55E/XJkxHkouvvh3hgpxwiwUWx8p4Hx8yKo8h3vWgWZ/BIM7cQ/P7uorF+dDL1B29EO95yrxx52MfGwrn7ik3cf5TsRk6c21OA4smnAWY6T/hRyfuCgclI8GUV9OoRWrLLQSz1oXxpPvfA+IUUeF/+CQbKn3DtPpSttT+ik0BBd347g+YxT7vV1SCPk/MAuIjPt+J/yE1uybabktkgw7RY8RM5mBuSQRSEdmHSRv5tFOTI/UFZIxOt1oJ2hVbnSlqfJEoZjDRGayFXLyMI/CSl/1zNEbOZE/q2V908QWhjzNWpmropC2p34Jl6lwTLKyg9OtHwcnnysn3dCWqaWFXlzHRE3JuHBStixyKIcIzc87DygMbxpYPy14DFKpfKAd0h/cBxl9XhPriBbvYCx5tdFUNafX0J2xtuubNR2tGFwHOVqAWl1Mlwe4alArcgbHPd8NIJy5Tvyd7MoK49D3Cyi5y0i/cnLPWa+eplB6YkCqrH3J2ZZ6KUuty+QddG/bAYrU2VkW90Eeh4p2tiOWrazXGXJzHnLt+4Hnzx6sR1Jyn1YHdIwc1WUp6Bpe6r+x7a2I8k2U2IfqtfrdfVNItqCahVkZKCfuIGlTWajmMpjKfBMbaKN58xmkJkeDjwrn4jas2V6pokomj0rfmiCw3TbWMtcfKKN0no+AxHFw2CaaJswc9U2hqBpMzmzmeCwbsxcfKLuslHUpEbEms9ARLEwzYOIqNtkSo6aJZlmig5tAjFBX3lziDm0RN3CYJqIiIiIKCGmeRARERERJcRgmoiIiIgoIQbTREREREQJMZgmIiIiIkqIwTQRERERUUIMpomIiIiIEmIwTURERESUEINpIiIiIqKEGEwTERERESXEYJqIiIiIKCEG00RERERECTGYJiIiIiJKiME0EREREVFC/z+P9QsAhuoeWwAAAABJRU5ErkJggg==)

# mlflow
"""

# Create requirements.txt
requirements = '''
streamlit
pandas
numpy
scikit-learn
xgboost
joblib
shap
matplotlib
mlflow
'''

with open("requirements.txt", "w") as f:
    f.write(requirements.strip())

print("✅ requirements.txt created")

import os
import random
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import joblib

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, classification_report, ConfusionMatrixDisplay


import mlflow
import mlflow.sklearn
from mlflow.models.signature import infer_signature

# Set seeds for reproducibility
SEED = 42
random.seed(SEED)
np.random.seed(SEED)
os.environ['PYTHONHASHSEED'] = str(SEED)

def load_data(path):
    df = pd.read_csv(path)
    return df

def preprocess_data(df):
    # Ensure 'name' column is dropped as it's not numeric
    X = df.drop(['name', 'status'], axis=1)
    y = df['status']
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X)
    # Convert scaled X back to DataFrame to preserve feature names for SHAP/MLflow input example
    X_scaled_df = pd.DataFrame(X_scaled, columns=X.columns)
    return train_test_split(X_scaled_df, y, test_size=0.2, random_state=SEED), scaler

def train_model(X_train, y_train, model):
    model.fit(X_train, y_train)
    return model

def evaluate_model(model, X_test, y_test):
    preds = model.predict(X_test)
    acc = accuracy_score(y_test, preds)
    report = classification_report(y_test, preds, output_dict=True)
    return acc, report, preds

def save_model(model, path):
    joblib.dump(model, path)

def load_model(path):
    return joblib.load(path)

# Example usage
if __name__ == "__main__":
    from catboost import CatBoostClassifier

    data_path = "/content/Parkinsson disease.csv"  # <- Replace with your real path
    df = load_data(data_path)
    (X_train, X_test, y_train, y_test), scaler = preprocess_data(df)

    model = CatBoostClassifier(
        n_estimators=1939,
        max_depth=5,
        learning_rate=0.266667, # Using a value in the optimized range from the previous cell (example value, replace with actual best_trial.params if different)
        l2_leaf_reg=0.045455, # Using a value in the optimized range from the previous cell (example value)
        border_count=20,
        leaf_estimation_iterations=60, # Using a value in the optimized range from the previous cell (example value)
        random_strength=0.05, # Using a value in the optimized range from the previous cell (example value)
        bagging_temperature=19,
        colsample_bylevel=0.3, # Using a value in the optimized range from the previous cell (example value)
        random_state=SEED,
        eval_metric='Accuracy',
        verbose=False
    )
    model_name = "CatBoost"


    with mlflow.start_run():
        mlflow.set_tag("author", "Your Name")
        mlflow.set_tag("model_type", model_name)

        mlflow.log_params(model.get_params())

        model = train_model(X_train, y_train, model)
        acc, report, preds = evaluate_model(model, X_test, y_test)

        mlflow.log_metric("accuracy", acc)
        for label, metrics in report.items():
            if isinstance(metrics, dict):
                for m_name, val in metrics.items():
                    mlflow.log_metric(f"{label}_{m_name}", val)

        # Confusion matrix plot
        disp = ConfusionMatrixDisplay.from_predictions(y_test, preds)
        plt.title("Confusion Matrix")
        plt.savefig("confusion_matrix.png")
        mlflow.log_artifact("confusion_matrix.png")
        plt.close()

        # Signature: use full X_test, not just predictions
        signature = infer_signature(X_test, model.predict(X_test))
        input_example = X_test[:5]

        mlflow.sklearn.log_model(model, artifact_path="model", signature=signature, input_example=input_example)

        # Save via joblib
        model_path = f"{model_name}_model.pkl"
        save_model(model, model_path)
        mlflow.log_artifact(model_path)

        print(f"Model saved to {model_path}, accuracy: {acc:.4f}")

import mlflow
print("MLflow version:", mlflow.__version__)

# ✅ Parkinson's Disease Detection with MLOps and XAI
# Enhanced version of your notebook with MLflow, SHAP, model saving, and reproducibility.

# Run in Colab: install required packages
# !pip install shap xgboost mlflow joblib matplotlib pandas scikit-learn

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import shap
import mlflow
import mlflow.sklearn
import joblib
import os

from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import accuracy_score, roc_auc_score
from xgboost import XGBClassifier
from mlflow.models.signature import infer_signature

# Load data (upload or adjust path if needed)
df = pd.read_csv("Parkinsson disease.csv")
df = df.drop(columns=["name"])

X = df.drop("status", axis=1)
y = df["status"]
feature_names = X.columns.tolist()

# Preprocessing
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y, test_size=0.2, random_state=42)

# Save scaler for deployment
os.makedirs("model", exist_ok=True)
joblib.dump(scaler, "model/scaler.pkl")

# Train model and log with MLflow
model = XGBClassifier(use_label_encoder=False, eval_metric="logloss", random_state=42)

with mlflow.start_run():
    model.fit(X_train, y_train)
    y_pred = model.predict(X_test)
    y_prob = model.predict_proba(X_test)[:, 1]

    acc = accuracy_score(y_test, y_pred)
    roc = roc_auc_score(y_test, y_prob)

    # Log parameters and metrics
    mlflow.log_param("model", "XGBoost")
    mlflow.log_metric("accuracy", acc)
    mlflow.log_metric("roc_auc", roc)

    # Save model
    joblib.dump(model, "model/xgb_model.pkl")
    signature = infer_signature(X_test, y_pred)
    mlflow.sklearn.log_model(model, "model", signature=signature)

    # SHAP explainability
    explainer = shap.Explainer(model)
    shap_values = explainer(X_test)

    shap_path = "model/shap_summary.png"
    plt.figure()
    shap.summary_plot(shap_values, X_test, feature_names=feature_names, show=False)
    plt.tight_layout()
    plt.savefig(shap_path)
    plt.close()
    mlflow.log_artifact(shap_path)

    print(f"Model accuracy: {acc:.4f}, ROC AUC: {roc:.4f}")
    print(f"Model, scaler, and SHAP summary plot saved in 'model/' folder.")